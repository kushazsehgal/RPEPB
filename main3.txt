package main

import (
    "encoding/csv"
    "fmt"
    "math"
    "math/rand"
    "os"
    "strconv"
    "time"

    "pooled_decrypt/models"
    "pooled_decrypt/scheme"
    "pooled_decrypt/utils"
)

// groupOrder should match the prime order of your elliptic curve / pairing group.
// For example, BN254's order is about 2.18e76. This is just a placeholder.
// GTEqual compares two GT elements by marshaling them to bytes.
func GTEqual(a, b models.GTElement) bool {
    aBytes, _ := a.E.MarshalBinary()
    bBytes, _ := b.E.MarshalBinary()
    return string(aBytes) == string(bBytes)
}

// pickRandomSubset returns 'count' distinct random integers in [0..max-1].
func pickRandomSubset(count, max int) []int {
    if count > max {
        panic("pickRandomSubset: count > max")
    }
    set := make(map[int]bool)
    for len(set) < count {
        idx := rand.Intn(max)
        set[idx] = true
    }
    // Convert to slice
    result := make([]int, 0, count)
    for k := range set {
        result = append(result, k)
    }
    return result
}

// ----------------------------------------------
// If you have a TraceDecrypt function (or method)
// that checks all indices i in [0..L], returning
// the first mismatch i-1, you can define it here
// or call your existing one.
// ----------------------------------------------
func traceDecryptTest(crs *models.CRS, mpk models.MasterPublicKey, sks []models.SecretKey, hskArr []models.HelperSecretKey) int {
    // This is a placeholder. Adjust to your actual implementation:
    // For i in [0..L], do "traceEncrypt" then "Decode" or partial decrypt + combine
    // If mismatch => return i-1. If all match => return L.

    L := crs.L
    for i := 0; i <= L; i++ {
        // Example "traceEncrypt" approach:
        psi := models.RandomScalar()
        // Z_im_bigInt might incorporate i in the encoding:
        x, y := utils.Z_im_bigInt(i, L, psi)
        ct := scheme.Encrypt(crs, mpk, x, y)

        // For threshold decryption, pick a subset:
        // (This might differ if your trace approach uses a single user or something else.)
        subset := pickRandomSubset(2, L) // Just an example; adjust as needed.
        partials := make([]models.GTElement, L)
        for _, u := range subset {
            partials[u] = scheme.Decrypt(crs, sks[u], u, hskArr[u], ct)
        }
        decGT := scheme.Combine(ct, partials, subset, models.Order)

        // Compare
        psiGT := models.GTGenerator().Exp(psi)
        if !GTEqual(decGT, psiGT) {
            return i - 1
        }
    }
    return L
}

func main() {
    rand.Seed(time.Now().UnixNano())

    // We’ll do an example with L=16. You can adjust or iterate over multiple L’s.
    Lvalues := []int{16}

    // CSV file setup
    csvFileName := "times.csv"
    file, err := os.OpenFile(csvFileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()
    writer := csv.NewWriter(file)
    defer writer.Flush()

    // Write header only if file is empty
    info, err := file.Stat()
    if err != nil {
        panic(err)
    }
    if info.Size() == 0 {
        writer.Write([]string{
            "L", "n1", "n2", "polyDeg",
            "setup_time_ms",
            "avg_keygen_time_ms",
            "aggregate_time_ms",
            "avg_enc_time_ms",
            "avg_threshold_dec_time_ms",
            "trace_decrypt_time_ms", // new column for trace
        })
    }

    for _, L := range Lvalues {
        // Example: polyDeg = T for threshold
        polyDeg := 5

        // n1, n2 as in your scheme
        sqrtL := int(math.Sqrt(float64(L)))
        n1 := 2 * sqrtL
        n2 := sqrtL + 1

        fmt.Printf("Benchmarking L=%d, n1=%d, n2=%d, polyDeg=%d\n", L, n1, n2, polyDeg)

        // ---------------- Setup ----------------
        startSetup := time.Now()
        crs := scheme.Setup(L, polyDeg)
        setupTime := time.Since(startSetup)

        // ---------------- Key Generation for L users ----------------
        var totalKeygen time.Duration
        pks := make([]models.PublicKey, L)
        sks := make([]models.SecretKey, L)
        for userIdx := 0; userIdx < L; userIdx++ {
            startKG := time.Now()
            pk, sk := scheme.Keygen(crs, userIdx)
            kgTime := time.Since(startKG)
            totalKeygen += kgTime
            pks[userIdx] = pk
            sks[userIdx] = sk
        }
        avgKeygen := totalKeygen / time.Duration(L)

        // ---------------- Aggregate ----------------
        startAgg := time.Now()
        mpk, hskArr := scheme.Aggregate(crs, pks)
        aggTime := time.Since(startAgg)

        // ---------------- Encryption / THRESHOLD Decryption Tests ----------------
        iterations := 20
        var totalEnc, totalTDec time.Duration

        for i := 0; i < iterations; i++ {
            // Generate random message
            psi := models.RandomScalar()
            x, y := utils.Z_bigInt(psi, L)

            // Encrypt
            startEnc := time.Now()
            ct := scheme.Encrypt(crs, mpk, x, y)
            encTime := time.Since(startEnc)
            totalEnc += encTime

            // Threshold decrypt
            startTDec := time.Now()

            // 1) Pick polyDeg+1 distinct users
            subset := pickRandomSubset(polyDeg+1, L)

            // 2) Each user does partial decrypt
            partials := make([]models.GTElement, L)
            for _, u := range subset {
                dL := scheme.Decrypt(crs, sks[u], u, hskArr[u], ct)
                partials[u] = dL
            }

            // 3) Combine partial decryptions
            mDecGT := scheme.Combine(ct, partials, subset, models.Order)
            tdecTime := time.Since(startTDec)
            totalTDec += tdecTime

            // Verify correctness
            expected := models.GTGenerator().Exp(psi)
            if !GTEqual(mDecGT, expected) {
                fmt.Printf("[FAIL] iteration=%d: threshold-dec mismatch (got != expected)\n", i)
            }
        }

        avgEnc := totalEnc / time.Duration(iterations)
        avgTDec := totalTDec / time.Duration(iterations)

        // ---------------- Trace Decrypt (Optional) ----------------
        // If you have a traceDecrypt function or want to measure it:
        startTrace := time.Now()
        traceRes := traceDecryptTest(crs, mpk, sks, hskArr)
        traceTime := time.Since(startTrace)
        fmt.Printf("TraceDecrypt returned: %d (time=%v ms)\n", traceRes, traceTime.Milliseconds())

        // ---------------- Write to CSV ----------------
        record := []string{
            strconv.Itoa(L),
            strconv.Itoa(n1),
            strconv.Itoa(n2),
            strconv.Itoa(polyDeg),
            fmt.Sprintf("%.4f", float64(setupTime.Milliseconds())),
            fmt.Sprintf("%.4f", float64(avgKeygen.Milliseconds())),
            fmt.Sprintf("%.4f", float64(aggTime.Milliseconds())),
            fmt.Sprintf("%.4f", float64(avgEnc.Milliseconds())),
            fmt.Sprintf("%.4f", float64(avgTDec.Milliseconds())),
            fmt.Sprintf("%.4f", float64(traceTime.Milliseconds())), // trace decrypt
        }
        writer.Write(record)

        fmt.Printf("L=%d n1=%d n2=%d polyDeg=%d\n", L, n1, n2, polyDeg)
        fmt.Printf("setup=%.4f ms | keygen=%.4f ms | agg=%.4f ms | enc=%.4f ms | threshold-dec=%.4f ms | trace-dec=%.4f ms\n",
            float64(setupTime.Milliseconds()),
            float64(avgKeygen.Milliseconds()),
            float64(aggTime.Milliseconds()),
            float64(avgEnc.Milliseconds()),
            float64(avgTDec.Milliseconds()),
            float64(traceTime.Milliseconds()))
    }
}
